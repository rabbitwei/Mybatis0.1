<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.rabbit.pojo">
    <!--这个例子是 one - many - one 的关系-->
    <!--=================================多对多：其实是 one -many -one ===================-->
    <resultMap id="orderBean" type="Order">
        <id column="oid" property="id"/>
        <result column="code" property="code"/>
        <!--一对多关系
           注意 ofType 属性，该属性的作用是： 用来将 JavaBean 属性的类型和集合存储的类型区分开来-->
        <collection property="orderItems" ofType="OrderItem">
            <id column="otid" property="id"/>
            <result column="number" property="number"/>
            <!--多对一关系-->
            <association property="product" javaType="Product">
                <id column="pid" property="id"/>
                <result column="pname" property="name"/>
                <result column="price" property="price"/>
            </association>
        </collection>
    </resultMap>

    <!--其实 resultMap 只是指定 sql 语句返回的结果是什么类型而已， 不过如果不是已有的类型，
    我们需要使用 resultMap 通过 字段与属性名 进行对应-->
    <select id="listOrder" resultMap="orderBean">
        select o.id 'oid', o.code, ot.id 'otid', ot.number, p.id 'pid', p.name 'pname', price
        from order_ o
        left join order_item_ ot on o.id = ot.oid
        left join product_ p on p.id = ot.pid
    </select>

    <select id="getOrder" resultMap="orderBean" parameterType="_int">
        select o.id 'oid', o.code, ot.id 'otid', ot.number, p.id 'pid', p.name 'pname', price
        from order_ o
        left join order_item_ ot on o.id = ot.oid
        left join product_ p on p.id = ot.pid
        where o.id = #{id}
    </select>


</mapper>